<!doctype html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Landscape REPL</title>

  <style>
    body { font-family: Arial, sans-serif; background:#f5f5f5; margin:20px; }
    table.selection-table { border-collapse:collapse; margin:0 auto 20px; width:80%; max-width:800px; background:#fff; }
    table.selection-table th, table.selection-table td { border:1px solid #888; padding:6px 10px; text-align:center; }
    table.selection-table thead { background:#f0f0f0; font-weight:bold; }
    .tabs { text-align:center; margin-bottom:10px; }
    .tablink { display:inline-block; padding:8px 16px; margin:0 4px; border:0; border-radius:4px 4px 0 0; background:#ddd; cursor:pointer; font-size:14px; }
    .tablink.active { background:#366536; color:#fff; }
    .tabcontent { display:none; position:relative; }
    fieldset.control-block { display:block; margin:15px auto; padding:15px; width:400px; max-width:95%; border:1px solid #aaa; border-radius:6px; background:#fff; box-shadow:0 2px 5px rgba(0,0,0,.1); }
    fieldset.control-block legend { font-weight:bold; }
    fieldset.control-block label { display:inline-block; width:140px; text-align:right; margin-right:8px; }
    fieldset.control-block input[type="number"] { width:120px; padding:3px; margin:3px 0; }
    fieldset.control-block input[type="button"] { margin:4px 0; padding:4px 10px; cursor:pointer; }
    .info-box { margin-top:10px; padding:6px; background:#f9f9f9; border:1px dashed #aaa; font-size:12px; min-height:30px; white-space:pre-wrap; }
    a { display:block; text-align:center; margin-top:20px; }
    .tab-help { position:absolute; right:10px; bottom:10px; padding:8px 12px; border:0; border-radius:8px; background:#366536; color:#fff; font-weight:600; cursor:pointer; box-shadow:0 6px 18px rgba(0,0,0,.2); }
    .tab-help:hover { filter:brightness(1.05); }
    .tab-help:active { transform:translateY(1px); }
    #log-box { margin-top:10px; padding:8px; background:#111; color:#0f0; font-family:monospace; font-size:12px; height:140px; overflow:auto; }
    .muted { opacity:.6; }
  </style>

  <script type="text/javascript">
    "use strict";

    // ================= helpers =================
    function AddLog(msg) {
      const box = document.getElementById('log-box');
      if (!box) return;
      const now = new Date().toLocaleTimeString();
      box.textContent += "\n[" + now + "] " + msg;
      box.scrollTop = box.scrollHeight;
    }
    
    function setInfo(id, msg) {
      const el = document.getElementById(id);
      if (el) el.textContent = msg;
    }
    function parseNumber(inputEl, def = 0) {
      let v = (typeof inputEl.valueAsNumber === 'number' && !isNaN(inputEl.valueAsNumber)) ? inputEl.valueAsNumber : NaN;
      if (isNaN(v)) {
        const p = parseFloat(String(inputEl.value || "").replace(',', '.'));
        v = Number.isFinite(p) ? p : def;
      }
      return v;
    }

    // =============== ожидание моста ACAPI (с диагностикой) ===============
    function whenACAPIReadyDo(cb) {
      let fired = false;
      const probe = () => {
        const A = window.ACAPI;
        if (!A) return null;
        return {
          hasSelect : typeof A.GetSelectedElements === 'function',
          hasGround : typeof A.ApplyGroundOffset  === 'function',
          hasNewDlt : typeof A.SetZDelta         === 'function' && typeof A.ApplyZDelta === 'function', // двухшаговый
          hasOldDlt : typeof A.ApplyZDelta       === 'function' && A.ApplyZDelta.length >= 1            // одноступенчатый
        };
      };
      const ready = () => {
        const caps = probe();
        return caps && (caps.hasSelect || caps.hasGround || caps.hasNewDlt || caps.hasOldDlt);
      };
      const fire = () => {
        if (fired) return;
        fired = true;
        try {
          const caps = probe();
          AddLog(`[UI] ACAPI готов: select=${!!caps.hasSelect} ground=${!!caps.hasGround} newΔ=${!!caps.hasNewDlt} oldΔ=${!!caps.hasOldDlt}`);
          cb();
        } catch (e) { AddLog('[UI] callback error: ' + e); }
      };

      if (ready()) { fire(); return; }

      let tries = 0;
      const maxTries = 120; // ~6 сек
      const iv = setInterval(() => {
        if (ready()) {
          clearInterval(iv);
          fire();
        } else if (++tries > maxTries) {
          clearInterval(iv);
          AddLog('[UI] ACAPI так и не появился (проверь загрузку палитры/плагина)');
        }
      }, 50);
    }

    // =============== таблица выделения ===============
    function UpdateSelectedElements() {
      const A = window.ACAPI;
      if (!A || typeof A.GetSelectedElements !== 'function') {
        AddLog('[UI] ACAPI.GetSelectedElements недоступен');
        return;
      }
      A.GetSelectedElements().then(function (elemInfos) {
        const selectionTable = document.getElementById('selection');
        while (selectionTable.firstChild) selectionTable.removeChild(selectionTable.firstChild);

        if (!elemInfos || elemInfos.length === 0) {
          const tr = document.createElement('tr');
          tr.innerHTML = '<td colspan="3">Нет выбранных элементов</td>';
          selectionTable.appendChild(tr);
          AddLog('[UI] Выделение пусто');
          return;
        }

        const grouped = {};
        for (let i = 0; i < elemInfos.length; i++) {
          const typeName = elemInfos[i][1];
          const elemID   = elemInfos[i][2];
          const key = typeName + "||" + elemID;
          if (!grouped[key]) grouped[key] = { type: typeName, id: elemID, count: 0 };
          grouped[key].count++;
        }
        Object.keys(grouped).forEach(key => {
          const tr = document.createElement('tr');
          tr.innerHTML =
            '<td>' + grouped[key].type + '</td>' +
            '<td>' + grouped[key].id   + '</td>' +
            '<td>' + grouped[key].count+ '</td>';
          selectionTable.appendChild(tr);
        });
        AddLog('[UI] Выделено групп: ' + Object.keys(grouped).length + ', элементов: ' + elemInfos.length);
      }).catch(err => AddLog('[UI] GetSelectedElements error: ' + err));
    }

    // =============== изменение ID элементов ===============
    function changeAllSelectedIDs() {
      const A = window.ACAPI;
      if (!A || typeof A.ChangeSelectedElementsID !== 'function') {
        AddLog('[UI] ACAPI.ChangeSelectedElementsID недоступен');
        return;
      }
      
      const baseID = document.getElementById('baseID').value.trim();
      if (!baseID) {
        AddLog('[UI] Введите базовое название для ID элементов');
        document.getElementById('baseID').focus();
        return;
      }
      
      AddLog('[UI] Изменяем ID элементов с базовым названием: ' + baseID);
      
      A.ChangeSelectedElementsID(baseID).then(function(success) {
        if (success) {
          AddLog('[UI] ✅ ID всех выбранных элементов успешно изменены!');
          setInfo("id-change-info", "✅ ID изменены! Примеры: " + baseID + "-01, " + baseID + "-02, " + baseID + "-03...");
          document.getElementById('baseID').value = '';
          setTimeout(UpdateSelectedElements, 1000);
        } else {
          AddLog('[UI] ❌ Ошибка при изменении ID элементов');
          setInfo("id-change-info", "❌ Ошибка! Возможно нет выбранных элементов или элемент не поддерживает изменение ID");
        }
      }).catch(function(err) {
        AddLog('[UI] ❌ Ошибка вызова ChangeSelectedElementsID: ' + err);
        setInfo("id-change-info", "❌ Ошибка: " + err);
      });
    }

    // =============== ориентация/раскладка/построение ===============
    function RotateSelection() {
      const s = document.getElementById('rotateAngle').value;
      if (window.ACAPI && typeof ACAPI.RotateSelected === 'function') ACAPI.RotateSelected(s);
      setInfo("info-orient", "Повернули на " + s + "°");
    }
    function AlignSelectionX()         { if (ACAPI?.AlignSelectedX)         ACAPI.AlignSelectedX();         setInfo("info-orient", "Выравнивание по X"); }
    function RandomizeAngles()         { if (ACAPI?.RandomizeSelectedAngles) ACAPI.RandomizeSelectedAngles(); setInfo("info-orient", "Случайный угол задан"); }
    function OrientObjectsToPoint()    { if (ACAPI?.OrientObjectsToPoint)    ACAPI.OrientObjectsToPoint();    setInfo("info-orient", "Сориентированы на точку"); }
    function SetDistributionLine()     { if (ACAPI?.SetDistributionLine)     ACAPI.SetDistributionLine();     setInfo("info-dist","Линия задана"); }
    function SetDistributionObject()   { if (ACAPI?.SetDistributionObject)   ACAPI.SetDistributionObject();   setInfo("info-dist","Объект задан"); }
    function SetDistributionStep () {
      const s = parseNumber(document.getElementById('distStep'), 0);
      const step = (isFinite(s) && s > 0) ? s : 0;
      if (ACAPI?.SetDistributionStep) ACAPI.SetDistributionStep(step);
      if (step > 0 && ACAPI?.DistributeNow) {
        const payload = "step:" + step;
        AddLog("[UI] Step OK → " + payload);
        ACAPI.DistributeNow(payload).then(ok => setInfo("info-dist", ok ? " Разложено по шагу" : " Ошибка раскладки"));
      } else if (step <= 0) setInfo("info-dist", "Шаг должен быть > 0");
    }
    function SetDistributionCount () {
      const c = parseInt((document.getElementById('distCount').value || "0"), 10);
      const count = (isFinite(c) && c > 0) ? c : 0;
      if (ACAPI?.SetDistributionCount) ACAPI.SetDistributionCount(count);
      if (count > 0 && ACAPI?.DistributeNow) {
        const payload = "count:" + count;
        AddLog("[UI] Count OK → " + payload);
        ACAPI.DistributeNow(payload).then(ok => setInfo("info-dist", ok ? " Разложено по количеству" : " Ошибка раскладки"));
      } else if (count <= 0) setInfo("info-dist", "Количество должно быть ≥ 1");
    }
    function CreateSlabAlongCurve(){
      const w = parseNumber(document.getElementById('slabWidth'), 0);
      if (ACAPI?.CreateSlabAlongCurve) ACAPI.CreateSlabAlongCurve(w);
      setInfo("info-build","Перекрытие, ширина=" + w);
    }
    function CreateShellAlongCurve(){
      const w = parseNumber(document.getElementById('shellWidth'), 0);
      if (ACAPI?.CreateShellAlongCurve) ACAPI.CreateShellAlongCurve(w);
      setInfo("info-build","Оболочка, ширина=" + w);
    }

    // ================= ОБОЛОЧКА =================
    function SelectBaseLine() {
      const A = window.ACAPI;
      if (!A) { AddLog('[Shell] ACAPI недоступен'); return; }
      if (!A.SetBaseLineForShell) {
        AddLog('[Shell] API функция SetBaseLineForShell недоступна');
        setInfo('info-shell', ' Функция недоступна (обновите плагин)');
        return;
      }

      AddLog('[Shell] Выбор базовой линии...');
      setInfo('info-shell', 'Выберите базовую линию (spline/polyline/дуга/линия)...');

      // Вызываем функцию выбора линии
      Promise.resolve(A.SetBaseLineForShell()).then(success => {
        if (success) {
          setInfo('info-shell', ' ✅ Базовая линия выбрана!');
          AddLog('[Shell] Базовая линия выбрана');
        } else {
          setInfo('info-shell', ' ❌ Не удалось выбрать линию');
          AddLog('[Shell] Ошибка выбора линии');
        }
      }).catch(e => {
        AddLog('[Shell] Ошибка: ' + e);
        setInfo('info-shell', ' ❌ Ошибка: ' + e);
      });
    }

    function SelectMeshSurface() {
      const A = window.ACAPI;
      if (!A) { AddLog('[Shell] ACAPI недоступен'); return; }
      if (!A.SetMeshSurfaceForShell) {
        AddLog('[Shell] API функция SetMeshSurfaceForShell недоступна');
        setInfo('info-shell', ' Функция недоступна (обновите плагин)');
        return;
      }

      AddLog('[Shell] Выбор Mesh поверхности...');
      setInfo('info-shell', 'Выберите Mesh элемент для получения высот...');

      // Вызываем функцию выбора Mesh
      Promise.resolve(A.SetMeshSurfaceForShell()).then(success => {
        if (success) {
          setInfo('info-shell', ' ✅ Mesh поверхность выбрана!');
          AddLog('[Shell] Mesh поверхность выбрана');
        } else {
          setInfo('info-shell', ' ❌ Не удалось выбрать Mesh');
          AddLog('[Shell] Ошибка выбора Mesh');
        }
      }).catch(e => {
        AddLog('[Shell] Ошибка: ' + e);
        setInfo('info-shell', ' ❌ Ошибка: ' + e);
      });
    }

    function CreateShellFromLine() {
      const A = window.ACAPI;
      if (!A) { AddLog('[Shell] ACAPI недоступен'); return; }
      if (!A.CreateShellFromLine) {
        AddLog('[Shell] API функция недоступна');
        setInfo('info-shell', ' Функция недоступна (обновите плагин)');
        return;
      }

      const width = parseNumber(document.getElementById('shellWidth'), 1000);
      const step = parseNumber(document.getElementById('shellStep'), 500);
      
      if (width <= 0) {
        setInfo('info-shell', 'Ширина должна быть > 0');
        return;
      }
      if (step <= 0) {
        setInfo('info-shell', 'Шаг должен быть > 0');
        return;
      }

      AddLog('[Shell] Создание оболочки: ширина=' + width + 'мм, шаг=' + step + 'мм');
      setInfo('info-shell', 'Создание оболочки...');

      // Вызываем функцию создания оболочки (передаем параметры через строку)
      const params = "width:" + width + ",step:" + step;
      AddLog('[Shell] Вызов ACAPI.CreateShellFromLine с параметрами: ' + params);
      Promise.resolve(A.CreateShellFromLine(params)).then(success => {
        if (success) {
          setInfo('info-shell', ' ✅ Оболочка создана!');
          AddLog('[Shell] SUCCESS');
        } else {
          setInfo('info-shell', ' ❌ Не удалось создать оболочку');
          AddLog('[Shell] FAILED');
        }
      }).catch(e => {
        AddLog('[Shell] Ошибка: ' + e);
        setInfo('info-shell', ' ❌ Ошибка: ' + e);
      });
    }
    function GenerateGDLFromSelection() {
      if (!ACAPI?.GenerateGDLFromSelection) { AddLog('[UI] ACAPI.GenerateGDLFromSelection недоступен'); return; }
      ACAPI.GenerateGDLFromSelection().then(code => {
        document.getElementById('gdlOutput').value = code || "Ничего не выделено или не поддерживается";
      });
    }

    // ================= РАЗМЕТКА =================
    function CreateMarkup() {
      const A = window.ACAPI;
      if (!A) { AddLog('[Markup] ACAPI недоступен'); return; }
      if (!A.SetMarkupStep || !A.CreateMarkupDimensions) {
        AddLog('[Markup] API функции недоступны');
        setInfo('info-markup', ' Функция недоступна (обновите плагин)');
        return;
      }

      const stepMM = parseNumber(document.getElementById('markupStep'), 1000);
      if (stepMM <= 0) {
        setInfo('info-markup', 'Шаг должен быть > 0');
        return;
      }

      AddLog('[Markup] Шаг = ' + stepMM + ' мм');
      setInfo('info-markup', 'Задайте направление карандашом...');

      // Устанавливаем шаг (передаём как строку, как в SetZDelta!)
      const stepOk = A.SetMarkupStep(String(stepMM));
      AddLog('[Markup] SetMarkupStep вызван с: ' + stepMM + ' (as string)');
      
      // Проверяем результат через Promise (если функция async)
      Promise.resolve(stepOk).then(ok => {
        AddLog('[Markup] SetMarkupStep результат: ' + ok);
        if (!ok) {
          setInfo('info-markup', ' Не удалось установить шаг');
          return;
        }

        // Вызываем разметку (блокирует UI, запрашивает линию)
        return A.CreateMarkupDimensions();
      }).then(created => {
        if (created) {
          setInfo('info-markup', ' Разметка создана!');
          AddLog('[Markup] SUCCESS');
        } else {
          setInfo('info-markup', ' Не удалось создать разметку (см. лог)');
          AddLog('[Markup] FAILED');
        }
      }).catch(e => {
        AddLog('[Markup] Ошибка: ' + e);
        setInfo('info-markup', ' Ошибка: ' + e);
      });
    }

    function CreateDimensionsToLine() {
      const A = window.ACAPI;
      if (!A) { AddLog('[Dimensions] ACAPI недоступен'); return; }
      if (!A.CreateDimensionsToLine) {
        AddLog('[Dimensions] API функция недоступна');
        setInfo('info-markup', ' Функция недоступна (обновите плагин)');
        return;
      }

      AddLog('[Dimensions] Запуск проставления размеров...');
      setInfo('info-markup', 'Задайте линию карандашом (2 точки)...');

      // Вызываем функцию (блокирует UI, запрашивает линию)
      Promise.resolve(A.CreateDimensionsToLine()).then(created => {
        if (created) {
          setInfo('info-markup', ' Размеры проставлены!');
          AddLog('[Dimensions] SUCCESS');
        } else {
          setInfo('info-markup', ' Не удалось проставить размеры (см. лог)');
          AddLog('[Dimensions] FAILED');
        }
      }).catch(e => {
        AddLog('[Dimensions] Ошибка: ' + e);
        setInfo('info-markup', ' Ошибка: ' + e);
      });
    }

    function CreateDimensionsBetweenObjects() {
      const A = window.ACAPI;
      if (!A) { AddLog('[Dimensions] ACAPI недоступен'); return; }
      if (!A.CreateDimensionsBetweenObjects) {
        AddLog('[Dimensions] API функция недоступна');
        setInfo('info-dimensions-between', ' Функция недоступна (обновите плагин)');
        return;
      }

      AddLog('[Dimensions] Запуск создания размеров между объектами...');
      setInfo('info-dimensions-between', 'Создание размеров между выделенными объектами...');

      // Вызываем функцию
      Promise.resolve(A.CreateDimensionsBetweenObjects()).then(created => {
        if (created) {
          setInfo('info-dimensions-between', ' Размеры созданы!');
          AddLog('[Dimensions] SUCCESS');
        } else {
          setInfo('info-dimensions-between', ' Не удалось создать размеры (см. лог)');
          AddLog('[Dimensions] FAILED');
        }
      }).catch(e => {
        AddLog('[Dimensions] Ошибка: ' + e);
        setInfo('info-dimensions-between', ' Ошибка: ' + e);
      });
    }

    function CreateDimensionsToPoint() {
      const A = window.ACAPI;
      if (!A) { AddLog('[Dimensions] ACAPI недоступен'); return; }
      if (!A.CreateDimensionsToPoint) {
        AddLog('[Dimensions] API функция недоступна');
        setInfo('info-dimensions-to-point', ' Функция недоступна (обновите плагин)');
        return;
      }

      AddLog('[Dimensions] Запуск создания размеров до точки...');
      setInfo('info-dimensions-to-point', 'Кликните точку на плане...');

      // Вызываем функцию
      Promise.resolve(A.CreateDimensionsToPoint()).then(created => {
        if (created) {
          setInfo('info-dimensions-to-point', ' Размеры созданы!');
          AddLog('[Dimensions] SUCCESS');
        } else {
          setInfo('info-dimensions-to-point', ' Не удалось создать размеры (см. лог)');
          AddLog('[Dimensions] FAILED');
        }
      }).catch(e => {
        AddLog('[Dimensions] Ошибка: ' + e);
        setInfo('info-dimensions-to-point', ' Ошибка: ' + e);
      });
    }


    // ================= ПРИЗЕМЛЕНИЕ / СМЕЩЕНИЕ =================
    // ΔZ БЕЗ MESH: SetGroundObjects + (новый или старый) ApplyZDelta
    async function ApplyZDeltaUI() {
      const A = window.ACAPI;
      if (!A) { AddLog('[ZDelta] ACAPI недоступен'); return; }

      const btn = document.getElementById('btnApplyOffset');
      btn?.setAttribute('disabled','disabled');

      const mm = parseNumber(document.getElementById('groundOffset'), 0);
      const meters = mm / 1000.0;
      AddLog('[ZDelta] ΔZ = ' + mm + ' мм (' + meters + ' м)');
      if (!isFinite(meters)) { setInfo('info-ground','Некорректное значение смещения'); btn?.removeAttribute('disabled'); return; }
      if (Math.abs(meters) < 1e-9) AddLog('[ZDelta] WARNING: delta≈0 — визуально может не измениться');

      try {
        const okObjs = await A.SetGroundObjects();
        AddLog('[ZDelta] SetGroundObjects → ' + okObjs);
        if (!okObjs) { setInfo('info-ground','Выберите объекты/колонны/светильники.'); return; }

        let applied = false;
        if (typeof A.SetZDelta === 'function' && typeof A.ApplyZDelta === 'function' && A.ApplyZDelta.length === 0) {
          // НОВЫЙ протокол: сначала буфером (строкой), потом вызов без аргумента
          AddLog('[ZDelta] Новый протокол: SetZDelta(m as string) → ApplyZDelta()');
          await A.SetZDelta(String(meters));
          applied = await A.ApplyZDelta();
        } else if (typeof A.ApplyZDelta === 'function') {
          // СТАРЫЙ протокол: единый вызов c числом
          AddLog('[ZDelta] Старый протокол: ApplyZDelta(m as number)');
          applied = await A.ApplyZDelta(meters);
        } else {
          throw new Error('ACAPI.ApplyZDelta недоступен');
        }

        setInfo('info-ground', applied ? ' Смещение выполнено (' + mm + ' мм)' : ' Ошибка смещения');
        AddLog('[ZDelta] Apply → ' + applied);
        if (applied) UpdateSelectedElements();
      } catch (e) {
        AddLog('[ZDelta] Ошибка: ' + e);
        setInfo('info-ground','Ошибка смещения — см. лог');
      } finally {
        btn?.removeAttribute('disabled');
      }
    }

    // ПОСАДКА НА MESH: SetGroundSurface + SetGroundObjects + ApplyGroundOffset(0)
    async function LandToMeshUI() {
      const A = window.ACAPI;
      if (!A) { AddLog('[Ground] ACAPI недоступен'); return; }

      const btnApply = document.getElementById('btnApplyOffset');
      const btnLand  = document.getElementById('btnLand');
      btnApply?.setAttribute('disabled','disabled');
      btnLand ?.setAttribute('disabled','disabled');
      setInfo('info-ground','Приземляю на поверхность…');

      try {
        const okSurf = await A.SetGroundSurface();
        AddLog('[Ground] SetGroundSurface → ' + okSurf);
        if (!okSurf) { setInfo('info-ground','Выберите Поверхность (3D-сетку).'); return; }

        const okObjs = await A.SetGroundObjects();
        AddLog('[Ground] SetGroundObjects → ' + okObjs);
        if (!okObjs) { setInfo('info-ground','Выберите объекты/колонны/светильники.'); return; }

        const applied = await A.ApplyGroundOffset(0.0); // offset игнорируется на C++
        AddLog('[Ground] ApplyGroundOffset(0) → ' + applied);
        setInfo('info-ground', applied ? ' Приземлено на Mesh' : ' Ошибка приземления');
        if (applied) UpdateSelectedElements();
      } catch (e) {
        AddLog('[Ground] Ошибка: ' + e);
        setInfo('info-ground','Ошибка при приземлении — см. лог');
      } finally {
        btnApply?.removeAttribute('disabled');
        btnLand ?.removeAttribute('disabled');
      }
    }

    // ===== совместимость со старым мостом (не мешают текущей логике) =====
    function onShift(mm) {
      const m = parseFloat(mm) / 1000;
      AddLog(`[UI] Shift click, delta=${m} m`);
      if (window.ACAPI_Call) ACAPI_Call('ApplyZDelta', m);
    }
    function onLand() {
      AddLog(`[UI] Land click`);
      if (window.ACAPI_Call) ACAPI_Call('ApplyGroundOffset', 0.0);
    }

    // =============== вкладки / init ===============
    function openTab(evt, tabId) {
      const contents = document.getElementsByClassName("tabcontent");
      const links = document.getElementsByClassName("tablink");
      for (let i = 0; i < contents.length; i++) contents[i].style.display = "none";
      for (let i = 0; i < links.length; i++) links[i].classList.remove("active");
      const tab = document.getElementById(tabId);
      if (tab) tab.style.display = "block";
      evt.currentTarget.classList.add("active");
      AddLog('[UI] Tab → ' + tabId);
    }
    window.openTab = openTab;

    window.addEventListener('DOMContentLoaded', function () {
      AddLog("[UI] Ready (UI v0.4)");
      AddLog("[UI] Поле для логов восстановлено и готово к работе!");

      // Enter-нажатия для числовых полей
      const step = document.getElementById('distStep');
      const cnt  = document.getElementById('distCount');
      step?.addEventListener('keydown', e => { if (e.key === 'Enter') SetDistributionStep(); });
      cnt ?.addEventListener('keydown',  e => { if (e.key === 'Enter') SetDistributionCount(); });
      
      // Enter для поля изменения ID - перенесено в вкладку "Слои (ID)"

      // Enter по смещению — как «Применить» (ΔZ)
      const offset = document.getElementById('groundOffset');
      offset?.addEventListener('keydown', e => { if (e.key === 'Enter') whenACAPIReadyDo(ApplyZDeltaUI); });

      // Enter для полей оболочки
      const shellWidth = document.getElementById('shellWidth');
      const shellStep = document.getElementById('shellStep');
      shellWidth?.addEventListener('keydown', e => { if (e.key === 'Enter') CreateShellFromLine(); });
      shellStep?.addEventListener('keydown', e => { if (e.key === 'Enter') CreateShellFromLine(); });

      // Делегирование кликов по любым элементам с data-help-url
      document.addEventListener('click', function (e) {
        const el = e.target.closest('[data-help-url]');
        if (!el) return;
        e.preventDefault();
        let url = el.getAttribute('data-help-url') || 'https://landscape.227.info/help/start';
        
        // Добавляем cache-busting параметр для обхода кеширования браузера
        const separator = url.includes('?') ? '&' : '?';
        const timestamp = Date.now();
        url = url + separator + 'v=' + timestamp;
        
        AddLog('[UI] help → ' + url);

        const A = window.ACAPI;
        if (A && typeof A.OpenHelp === 'function') {
          Promise.resolve(A.OpenHelp(url))
            .then(() => AddLog('[UI] ACAPI.OpenHelp ok'))
            .catch(err => AddLog('[UI] ACAPI.OpenHelp error: ' + err));
        } else {
          AddLog('[UI] ACAPI.OpenHelp не найден → window.open');
          window.open(url, '_blank', 'noopener,noreferrer');
        }
      });

      // ждём мост и только затем обновляем таблицу
      whenACAPIReadyDo(() => {
        UpdateSelectedElements();
      });

      // вкладка по умолчанию
      // const def = document.getElementById("defaultTab");
      // if (def) def.click();
      
      // Открываем вкладку "Распределение" по умолчанию
      const distribTab = document.querySelector('button[onclick*="tab-distrib"]');
      if (distribTab) distribTab.click();
    });
  </script>
</head>

<body>
  <!-- Таблица выделения -->
  <table class="selection-table">
    <thead>
      <tr><th colspan="3">Выбранные элементы:</th></tr>
      <tr><th>Тип</th><th>ID</th><th>Кол-во</th></tr>
    </thead>
    <tbody id="selection"><tr><td colspan="3">Нет выбранных элементов</td></tr></tbody>
  </table>

  <!-- Форма изменения ID перенесена в вкладку "Слои (ID)" -->

  <!-- Вкладки -->
  <div class="tabs">
    <!-- <button id="defaultTab" class="tablink" onclick="openTab(event,'tab-build')">Построение</button> -->
    <button class="tablink" onclick="openTab(event,'tab-distrib')">Распределение</button>
    <button class="tablink" onclick="openTab(event,'tab-orient')">Ориентация</button>
    <button class="tablink" onclick="openTab(event,'tab-ground')">Приземление</button>
    <button class="tablink" onclick="openTab(event,'tab-markup')">Разметка</button>
    <button class="tablink" onclick="openTab(event,'tab-shell')">Контуры</button>
    <button class="tablink" onclick="openTab(event,'tab-gdl')">GDL</button>
  </div>

  <!-- Построение -->
  <!--
  <div id="tab-build" class="tabcontent">
    <fieldset class="control-block">
      <legend>Перекрытие по линии</legend>
      <div style="text-align:center; margin-bottom:6px;">
        <input type="button" onclick="ACAPI.SetCurveForSlab && ACAPI.SetCurveForSlab()" value="Выбрать линию">
      </div>
      <div>
        <label>Ширина:</label>
        <input type="number" id="slabWidth" step="1" value="1000">
        <input type="button" onclick="CreateSlabAlongCurve()" value="Построить Перекрытие">
      </div>
    </fieldset>

    <fieldset class="control-block">
      <legend>Оболочка по линии</legend>
      <div style="text-align:center; margin-bottom:6px;">
        <input type="button" onclick="ACAPI.SetCurveForShell && ACAPI.SetCurveForShell()" value="Выбрать линию"><br><br>
        <input type="button" onclick="ACAPI.SetMeshForShell && ACAPI.SetMeshForShell()" value="Выбрать 3D сетку">
      </div>
      <div>
        <label>Ширина:</label>
        <input type="number" id="shellWidth" step="1" value="1000">
        <input type="button" onclick="CreateShellAlongCurve()" value="OK">
      </div>
      <div style="text-align:center; margin-top:10px;">
        <input type="button" onclick="CreateShellAlongCurve()" value="Построить Оболочку">
      </div>
      <div id="info-build" class="info-box">Подсказка: выберите линию/сетку и задайте параметры</div>
    </fieldset>

    <button class="tab-help"
            data-help-url="https://landscape.227.info/help/buildshell?embed=1"
            data-help-title="Справка: Построение">Помощь</button>
  </div>
  -->

  <!-- Распределение -->
  <div id="tab-distrib" class="tabcontent">
    <fieldset class="control-block">
      <legend>Распределение</legend>
      <div style="text-align:center;">
        <input type="button" onclick="SetDistributionLine()" value="Задать линию"><br><br>
        <input type="button" onclick="SetDistributionObject()" value="Задать объект">
      </div>
      <div>
        <label>Расстояние:</label>
        <input type="number" id="distStep" step="1" value="0">
        <input type="button" onclick="SetDistributionStep()" value="OK">
      </div>
      <div>
        <label>Количество:</label>
        <input type="number" id="distCount" step="1" value="1">
        <input type="button" onclick="SetDistributionCount()" value="OK">
      </div>
      <div id="info-dist" class="info-box">Подсказка: задайте параметры</div>
    </fieldset>

    <button class="tab-help"
            data-help-url="https://landscape.227.info/help/distribution?embed=1"
            data-help-title="Справка: Распределение">Помощь</button>
  </div>

  <!-- Ориентация -->
  <div id="tab-orient" class="tabcontent">
    <fieldset class="control-block">
      <legend>Ориентация</legend>
      <div>
        <label>Угол:</label>
        <input type="number" id="rotateAngle" step="1" value="0">
        <input type="button" onclick="RotateSelection()" value="Повернуть">
      </div>
      <div style="text-align:center; margin-top:10px;">
        <input type="button" onclick="AlignSelectionX()" value="Выровнять по X"><br><br>
        <input type="button" onclick="RandomizeAngles()" value="Случайный угол (0-360)"><br><br>
        <input type="button" onclick="OrientObjectsToPoint()" value="Сориентировать на точку">
      </div>
      <div id="info-orient" class="info-box">Подсказка: задайте угол или выберите действие</div>
    </fieldset>

    <button class="tab-help"
            data-help-url="https://landscape.227.info/help/orientation?embed=1"
            data-help-title="Справка: Ориентация">Помощь</button>
  </div>

  <!-- Приземление -->
  <div id="tab-ground" class="tabcontent">
    <fieldset class="control-block">
      <legend>Приземление</legend>

      <div style="text-align:center; margin-bottom:10px;">
        <label>Смещение Z (мм):</label>
        <input type="number" id="groundOffset" step="1" value="0">
        <!-- Применить = ΔZ -->
        <input id="btnApplyOffset" type="button" onclick="whenACAPIReadyDo(ApplyZDeltaUI)" value="Применить">
      </div>

      <div style="text-align:center;">
        <!-- Приземлить = посадка на mesh -->
        <input id="btnLand" type="button" onclick="whenACAPIReadyDo(LandToMeshUI)" value="Приземлить">
      </div>

      <div id="info-ground" class="info-box">
        Режимы: «Применить» — просто сдвиг по Z (без mesh). «Приземлить» — посадка на выделенную 3D-сетку (смещение игнорируется).
      </div>
    </fieldset>

    <button class="tab-help"
            data-help-url="https://landscape.227.info/help/ground?embed=1"
            data-help-title="Справка: Приземление">Помощь</button>
  </div>

  <!-- Разметка -->
  <div id="tab-markup" class="tabcontent">
    <fieldset class="control-block">
      <legend>Разметка размерами</legend>

      <div style="text-align:center; margin-bottom:10px;">
        <p style="font-size:12px; color:#666;">
          1. Выделите элементы (Mesh/Slab/Wall/Shell)<br>
          2. Задайте шаг<br>
          3. Нажмите кнопку и кликните <b>2 точки</b> для направления
        </p>
      </div>

      <div>
        <label>Шаг разметки (мм):</label>
        <input type="number" id="markupStep" step="1" value="1000">
      </div>

      <div style="text-align:center; margin-top:15px;">
        <input type="button" 
               onclick="CreateMarkup()" 
               value="Разметить"
               style="font-size:16px; padding:8px 20px; font-weight:bold;">
      </div>

      <div id="info-markup" class="info-box">
        Создаёт размеры ШИРИНЫ элемента перпендикулярно направлению.<br>
        Размеры расставляются СТРОГО ПО ШАГУ от линии до ближайшей точки контура.<br>
        Линия направления не обязана проходить через элемент - можно задать сбоку (например, вдоль забора).
      </div>
    </fieldset>

    <fieldset class="control-block">
      <legend>Проставить размеры до линии</legend>

      <div style="text-align:center; margin-bottom:10px;">
        <p style="font-size:12px; color:#666;">
          1. Выделите объекты, колонны или светильники<br>
          2. Нажмите кнопку и кликните <b>2 точки</b> для линии<br>
          3. Размеры появятся перпендикулярно линии от точек привязки
        </p>
      </div>

      <div style="text-align:center; margin-top:15px;">
        <input type="button" 
               onclick="CreateDimensionsToLine()" 
               value="Проставить размеры"
               style="font-size:16px; padding:8px 20px; font-weight:bold;">
      </div>
    </fieldset>

    <fieldset class="control-block">
      <legend>Размеры между объектами</legend>

      <div style="text-align:center; margin-bottom:10px;">
        <p style="font-size:12px; color:#666;">
          1. Выделите несколько объектов (объекты, колонны, светильники)<br>
          2. Нажмите кнопку<br>
          3. Объекты отсортируются по координатам и размеры появятся последовательно (1→2, 2→3, 3→4...)
        </p>
      </div>

      <div style="text-align:center; margin-top:15px;">
        <input type="button" 
               onclick="CreateDimensionsBetweenObjects()" 
               value="Размеры между объектами"
               style="font-size:16px; padding:8px 20px; font-weight:bold;">
      </div>

      <div id="info-dimensions-between" class="info-box">
        Создаёт размеры расстояния между объектами последовательно.<br>
        Поддерживаются: объекты, колонны, светильники.<br>
        Объекты сортируются по координатам (X, затем Y), размеры создаются между соседними объектами (1→2, 2→3, 3→4...).
      </div>
    </fieldset>

    <fieldset class="control-block">
      <legend>Размеры до точки</legend>

      <div style="text-align:center; margin-bottom:10px;">
        <p style="font-size:12px; color:#666;">
          1. Выделите объекты (объекты, колонны, светильники)<br>
          2. Нажмите кнопку и кликните <b>точку</b> на плане<br>
          3. Размеры появятся от каждого объекта до выбранной точки
        </p>
      </div>

      <div style="text-align:center; margin-top:15px;">
        <input type="button" 
               onclick="CreateDimensionsToPoint()" 
               value="Размеры до точки"
               style="font-size:16px; padding:8px 20px; font-weight:bold;">
      </div>

      <div id="info-dimensions-to-point" class="info-box">
        Создаёт размеры от всех выделенных объектов до выбранной точки.<br>
        Поддерживаются: объекты, колонны, светильники.<br>
        Полезно для разметки до контрольных точек, углов, центров и т.д.
      </div>
    </fieldset>


    <button class="tab-help"
            data-help-url="https://landscape.227.info/help/dimensions"
            data-help-title="Справка: Разметка">Помощь</button>
  </div>

  <!-- Контуры -->
  <div id="tab-shell" class="tabcontent">
    <fieldset class="control-block">
      <legend>Создание контуров по линии</legend>

      <div style="text-align:center; margin-bottom:10px;">
        <p style="font-size:12px; color:#666;">
          1. Нажмите "Выбрать линию" и выберите базовую линию<br>
          2. Задайте ширину контура<br>
          3. Нажмите кнопку для создания контуров<br>
          <strong>Примечание:</strong> Для spline нужен шаг, для остальных линий - только ширина
        </p>
      </div>

      <div style="text-align:center; margin-bottom:10px;">
        <input type="button" 
               onclick="SelectBaseLine()" 
               value="Выбрать линию"
               style="font-size:14px; padding:6px 15px; font-weight:bold;">
      </div>

      <div>
        <label>Ширина (мм):</label>
        <input type="number" id="shellWidth" step="1" value="1000">
      </div>

      <div>
        <label>Шаг (мм):</label>
        <input type="number" id="shellStep" step="1" value="500">
      </div>

      <div style="text-align:center; margin-top:15px;">
        <input type="button" 
               onclick="CreateShellFromLine()" 
               value="Создать контуры"
               style="font-size:16px; padding:8px 20px; font-weight:bold;">
      </div>

      <div id="info-shell" class="info-box">
        Создаёт контуры по базовой линии с заданными параметрами.<br>
        <strong>Для spline:</strong> откладывает точки с заданным шагом, строит перпендикуляры<br>
        <strong>Для остальных линий:</strong> проверяет замкнутость, строит перпендикуляры в начале/конце<br>
        Создаёт два боковых контура с замыкающими линиями (для открытых линий).<br>
        <strong>Внимание:</strong> Сначала выберите базовую линию (spline/polyline/дуга/линия).
      </div>
    </fieldset>

    <button class="tab-help"
            data-help-url="https://landscape.227.info/help/shell"
            data-help-title="Справка: Оболочка">Помощь</button>
  </div>

  <!-- GDL -->
  <div id="tab-gdl" class="tabcontent">
    <fieldset class="control-block">
      <legend>GDL-код из выделения</legend>
      <div style="text-align:center;">
        <input type="button" onclick="GenerateGDLFromSelection()" value="Создать GDL">
      </div>
      <textarea id="gdlOutput" style="width:95%;height:200px;margin-top:10px;font-family:monospace;"></textarea>
    </fieldset>

    <button class="tab-help"
            data-help-url="https://landscape.227.info/help/gdl?embed=1"
            data-help-title="Справка: GDL">Помощь</button>
  </div>

  <div id="log-box">[Лог плагина будет здесь]</div>

  <a href="#"
     data-help-url="https://landscape.227.info/?embed=1"
     data-help-title="LandscapeHelper — сайт">
    landscape.227.info
  </a>
</body>
</html>
